<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>04｜get hands dirty：来写个实用的CLI小工具 - Rust 时刻(Rust Time)</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/style3.css">


    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');
                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }
                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../0-startup/index.html">开篇词｜让Rust成为你的下一门主力语言</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">前置篇</li><li class="chapter-item expanded "><a href="../1-memory/index.html"><strong aria-hidden="true">1.</strong> 内存：值放堆上还是放栈上，这是一个问题</a></li><li class="chapter-item expanded "><a href="../2-principles/index.html"><strong aria-hidden="true">2.</strong> 串讲：编程开发中，那些你需要掌握的基本概念</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">基础篇</li><li class="chapter-item expanded "><a href="../3-codeup/index.html"><strong aria-hidden="true">3.</strong> 03｜初窥门径：从你的第一个Rust程序开始！</a></li><li class="chapter-item expanded "><a href="../4-httpie/index.html" class="active"><strong aria-hidden="true">4.</strong> 04｜get hands dirty：来写个实用的CLI小工具</a></li><li class="chapter-item expanded "><a href="../5-thumbor/index.html"><strong aria-hidden="true">5.</strong> 05｜get hands dirty：做一个图片服务器有多难？</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">期中周</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">进阶篇</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">并发篇</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">实战篇</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">高级篇</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">结束语</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">学习锦囊</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 时刻(Rust Time)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <h1 id="04get-hands-dirty来写个实用的cli小工具"><a class="header" href="#04get-hands-dirty来写个实用的cli小工具">04｜get hands dirty：来写个实用的CLI小工具</a></h1>
<h2 id="httpie"><a class="header" href="#httpie">HTTPie</a></h2>
<p>为了覆盖绝大多数同学的需求，这次挑选的例子是工作中普遍会遇到的：写一个 CLI 工具，辅助我们处理各种任务。</p>
<p>我们就以实现 <a href="https://httpie.io/">HTTPie</a> 为例，看看用 Rust 怎么做 CLI。HTTPie 是用 Python 开发的，一个类似 cURL 但对用户更加友善的命令行工具，它可以帮助我们更好地诊断 HTTP 服务。</p>
<p>下图是用 HTTPie 发送了一个 post 请求的界面，你可以看到，相比 cURL，它在可用性上做了很多工作，包括对不同信息的语法高亮显示：</p>
<p><img src="./httpie-usage.webp" alt="" /></p>
<p>你可以先想一想，如果用你最熟悉的语言实现 HTTPie ，要怎么设计、需要用到些什么库、大概用多少行代码？如果用 Rust 的话，又大概会要多少行代码？</p>
<p>带着你自己的这些想法，开始动手用 Rust 构建这个工具吧！我们的目标是，用大约 200 行代码实现这个需求。</p>
<h2 id="功能分析"><a class="header" href="#功能分析">功能分析</a></h2>
<p>要做一个 HTTPie 这样的工具，我们先梳理一下要实现哪些主要功能：</p>
<ul>
<li>首先是做命令行解析，处理子命令和各种参数，验证用户的输入，并且将这些输入转换成我们内部能理解的参数；</li>
<li>之后根据解析好的参数，发送一个 HTTP 请求，获得响应；</li>
<li>最后用对用户友好的方式输出响应。</li>
</ul>
<p>这个流程你可以再看下图：</p>
<p><img src="./workflow.webp" alt="" /></p>
<p>我们来看要实现这些功能对应需要用到的库：</p>
<ul>
<li>对于命令行解析，Rust 有很多库可以满足这个需求，我们今天使用官方比较推荐的 <a href="https://github.com/clap-rs/clap">clap</a>。</li>
<li>对于 HTTP 客户端，在上一讲我们已经接触过 <a href="https://github.com/seanmonstar/reqwest">reqwest</a>，我们就继续使用它，只不过我们这次尝个鲜，使用它的异步接口。</li>
<li>对于格式化输出，为了让输出像 Python 版本的 HTTPie 那样显得生动可读，我们可以引入一个命令终端多彩显示的库，这里我们选择比较简单的 <a href="https://github.com/mackwic/colored">colored</a>。</li>
<li>除此之外，我们还需要一些额外的库：用 anyhow 做错误处理、用 jsonxf 格式化 JSON 响应、用 mime 处理 mime 类型，以及引入 tokio 做异步处理。</li>
</ul>
<h2 id="cli-处理"><a class="header" href="#cli-处理">CLI 处理</a></h2>
<p>好，有了基本的思路，我们来创建一个项目，名字就叫 httpie：</p>
<pre><code class="language-bash">cargo new httpie
cd httpie
</code></pre>
<p>然后，用 VSCode 打开项目所在的目录，编辑 Cargo.toml 文件，添加所需要的依赖（注意：以下代码用到了 beta 版本的 crate，可能未来会有破坏性更新，如果在本地无法编译，请参考 <a href="https://github.com/tyrchen/geektime-rust/tree/master/04_httpie">GitHub repo</a> 中的代码）：</p>
<pre><code class="language-toml">[package]
name = &quot;httpie&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[[example]]
name = &quot;cli&quot;

[[example]]
name = &quot;cli_verify&quot;

[[example]]
name = &quot;cli_get&quot;

[dependencies]
anyhow = &quot;1&quot; # 错误处理
clap = { version = &quot;3&quot;, features = [&quot;derive&quot;] } # 命令行解析
colored = &quot;2&quot; # 命令终端多彩显示
jsonxf = &quot;1.1&quot; # JSON pretty print 格式化
mime = &quot;0.3&quot; # 处理 mime 类型
# reqwest 默认使用 openssl，有些 linux 用户如果没有安装好 openssl 会无法编译，这里我改成了使用 rustls
reqwest = { version = &quot;0.11&quot;, default-features = false, features = [&quot;json&quot;, &quot;rustls-tls&quot;] } # HTTP 客户端
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] } # 异步处理库
syntect = &quot;4&quot;
</code></pre>
<p>我们先在 main.rs 添加处理 CLI 相关的代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use clap::{AppSettings, Clap};

// 定义 HTTPie 的 CLI 的主入口，它包含若干个子命令
// 下面 /// 的注释是文档，clap 会将其作为 CLI 的帮助

/// A naive httpie implementation with Rust, can you imagine how easy it is?
#[derive(Clap, Debug)]
#[clap(version = &quot;1.0&quot;, author = &quot;Tyr Chen &lt;tyr@chen.com&gt;&quot;)]
#[clap(setting = AppSettings::ColoredHelp)]
struct Opts {
    #[clap(subcommand)]
    subcmd: SubCommand,
}

// 子命令分别对应不同的 HTTP 方法，目前只支持 get / post
#[derive(Clap, Debug)]
enum SubCommand {
    Get(Get),
    Post(Post),
    // 我们暂且不支持其它 HTTP 方法
}

// get 子命令

/// feed get with an url and we will retrieve the response for you
#[derive(Clap, Debug)]
struct Get {
    /// HTTP 请求的 URL
    url: String,
}

// post 子命令。需要输入一个 URL，和若干个可选的 key=value，用于提供 json body

/// feed post with an url and optional key=value pairs. We will post the data
/// as JSON, and retrieve the response for you
#[derive(Clap, Debug)]
struct Post {
    /// HTTP 请求的 URL
    url: String,
    /// HTTP 请求的 body
    body: Vec&lt;String&gt;,
}

fn main() {
    let opts: Opts = Opts::parse();
    println!(&quot;{:?}&quot;, opts);
} 
</code></pre></pre>
<p>代码中用到了 clap 提供的宏来让 CLI 的定义变得简单，这个宏能够生成一些额外的代码帮我们处理 CLI 的解析。通过 clap ，我们只需要先用一个数据结构 T 描述 CLI 都会捕获什么数据，之后通过 T::parse() 就可以解析出各种命令行参数了。parse() 函数我们并没有定义，它是 #[derive(Clap)] 自动生成的。</p>
<p>目前我们定义了两个子命令，在 Rust 中子命令可以通过 enum 定义，每个子命令的参数又由它们各自的数据结构 Get 和 Post 来定义。</p>
<p>我们运行一下：</p>
<pre><code class="language-bash">❯ cargo build --quiet &amp;&amp; target/debug/httpie post httpbin.org/post a=1 b=2
Opts { subcmd: Post(Post { url: &quot;httpbin.org/post&quot;, body: [&quot;a=1&quot;, &quot;b=2&quot;] }) }
</code></pre>
<p>默认情况下，cargo build 编译出来的二进制，在项目根目录的 target/debug 下。可以看到，命令行解析成功，达到了我们想要的功能。</p>
<h2 id="加入验证"><a class="header" href="#加入验证">加入验证</a></h2>
<p>然而，现在我们还没对用户输入做任何检验，如果有这样的输入，URL 就完全解析错误了：</p>
<pre><code class="language-bash">❯ cargo build --quiet &amp;&amp; target/debug/httpie post a=1 b=2
Opts { subcmd: Post(Post { url: &quot;a=1&quot;, body: [&quot;b=2&quot;] }) }
</code></pre>
<p>所以，我们需要加入验证。输入有两项，就要做两个验证，一是验证 URL，另一个是验证 body。</p>
<p>首先来验证 URL 是合法的：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyhow::Result;
use reqwest::Url;

#[derive(Clap, Debug)]
struct Get {
    /// HTTP 请求的 URL
    #[clap(parse(try_from_str = parse_url))]
    url: String,
}

fn parse_url(s: &amp;str) -&gt; Result&lt;String&gt; {
    // 这里我们仅仅检查一下 URL 是否合法
    let _url: Url = s.parse()?;

    Ok(s.into())
}
<span class="boring">}
</span></code></pre></pre>
<p>clap 允许你为每个解析出来的值添加自定义的解析函数，我们这里定义了个 parse_url 检查一下。</p>
<p>然后，我们要确保 body 里每一项都是 key=value 的格式。可以定义一个数据结构 KvPair 来存储这个信息，并且也自定义一个解析函数把解析的结果放入 KvPair：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::str::FromStr;
use anyhow::{anyhow, Result};

#[derive(Clap, Debug)]
struct Post {
    /// HTTP 请求的 URL
    #[clap(parse(try_from_str = parse_url))]
    url: String,
    /// HTTP 请求的 body
    #[clap(parse(try_from_str=parse_kv_pair))]
    body: Vec&lt;KvPair&gt;,
}

/// 命令行中的 key=value 可以通过 parse_kv_pair 解析成 KvPair 结构
#[derive(Debug)]
struct KvPair {
    k: String,
    v: String,
}

/// 当我们实现 FromStr trait 后，可以用 str.parse() 方法将字符串解析成 KvPair
impl FromStr for KvPair {
    type Err = anyhow::Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        // 使用 = 进行 split，这会得到一个迭代器
        let mut split = s.split(&quot;=&quot;);
        let err = || anyhow!(format!(&quot;Failed to parse {}&quot;, s));
        Ok(Self {
            // 从迭代器中取第一个结果作为 key，迭代器返回 Some(T)/None
            // 我们将其转换成 Ok(T)/Err(E)，然后用 ? 处理错误
            k: (split.next().ok_or_else(err)?).to_string(),
            // 从迭代器中取第二个结果作为 value
            v: (split.next().ok_or_else(err)?).to_string(),
        })
    }
}

/// 因为我们为 KvPair 实现了 FromStr，这里可以直接 s.parse() 得到 KvPair
fn parse_kv_pair(s: &amp;str) -&gt; Result&lt;KvPair&gt; {
    Ok(s.parse()?)
}
<span class="boring">}
</span></code></pre></pre>
<p>这里我们实现了一个 <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html">FromStr trait</a>，可以把满足条件的字符串转换成 KvPair。FromStr 是 Rust 标准库定义的 trait，实现它之后，就可以调用字符串的 parse() 泛型函数，很方便地处理字符串到某个类型的转换了。</p>
<p>这样修改完成后，我们的 CLI 就比较健壮了，可以再测试一下：</p>
<pre><code class="language-bash">❯ cargo build --quiet
❯ target/debug/httpie post https://httpbin.org/post a=1 b
error: Invalid value for '&lt;BODY&gt;...': Failed to parse b

For more information try --help
❯ target/debug/httpie post abc a=1
error: Invalid value for '&lt;URL&gt;': relative URL without a base

For more information try --help

target/debug/httpie post https://httpbin.org/post a=1 b=2
Opts { subcmd: Post(Post { url: &quot;https://httpbin.org/post&quot;, body: [KvPair { k: &quot;a&quot;, v: &quot;1&quot; }, KvPair { k: &quot;b&quot;, v: &quot;2&quot; }] }) }
</code></pre>
<p>Cool，我们完成了基本的验证，不过很明显可以看到，我们并没有把各种验证代码一股脑塞在主流程中，而是通过实现额外的验证函数和 trait 来完成的，这些新添加的代码，高度可复用且彼此独立，并不用修改主流程。</p>
<p>这非常符合软件开发的<a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">开闭原则（Open-Closed Principle）</a>：Rust 可以通过宏、trait、泛型函数、trait object 等工具，帮助我们更容易写出结构良好、容易维护的代码。</p>
<p>目前你也许还不太明白这些代码的细节，但是不要担心，继续写，今天先把代码跑起来就行了，不需要你搞懂每个知识点，之后我们都会慢慢讲到的。</p>
<h2 id="http-请求"><a class="header" href="#http-请求">HTTP 请求</a></h2>
<p>好，接下来我们就继续进行 HTTPie 的核心功能：HTTP 的请求处理了。我们在 main() 函数里添加处理子命令的流程：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use reqwest::{header, Client, Response, Url};

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let opts: Opts = Opts::parse();
    // 生成一个 HTTP 客户端
    let client = Client::new();
    let result = match opts.subcmd {
        SubCommand::Get(ref args) =&gt; get(client, args).await?,
        SubCommand::Post(ref args) =&gt; post(client, args).await?,
    };

    Ok(result)
}
</code></pre></pre>
<p>注意看我们把 main 函数变成了 async fn，它代表异步函数。对于 async main，我们需要使用 #[tokio::main] 宏来自动添加处理异步的运行时。</p>
<p>然后在 main 函数内部，我们根据子命令的类型，我们分别调用 get 和 post 函数做具体处理，这两个函数实现如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{collections::HashMap, str::FromStr};

async fn get(client: Client, args: &amp;Get) -&gt; Result&lt;()&gt; {
    let resp = client.get(&amp;args.url).send().await?;
    println!(&quot;{:?}&quot;, resp.text().await?);
    Ok(())
}

async fn post(client: Client, args: &amp;Post) -&gt; Result&lt;()&gt; {
    let mut body = HashMap::new();
    for pair in args.body.iter() {
        body.insert(&amp;pair.k, &amp;pair.v);
    }
    let resp = client.post(&amp;args.url).json(&amp;body).send().await?;
    println!(&quot;{:?}&quot;, resp.text().await?);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>其中，我们解析出来的 KvPair 列表，需要装入一个 HashMap，然后传给 HTTP client 的 JSON 方法。这样，我们的 HTTPie 的基本功能就完成了。</p>
<p>不过现在打印出来的数据对用户非常不友好，我们需要进一步用不同的颜色打印 HTTP header 和 HTTP body，就像 Python 版本的 HTTPie 那样，这部分代码比较简单，我们就不详细介绍了。</p>
<p>最后，来看完整的代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use anyhow::{anyhow, Result};
use clap::{AppSettings, Clap};
use colored::*;
use mime::Mime;
use reqwest::{header, Client, Response, Url};
use std::{collections::HashMap, str::FromStr};

// 以下部分用于处理 CLI

// 定义 HTTPie 的 CLI 的主入口，它包含若干个子命令
// 下面 /// 的注释是文档，clap 会将其作为 CLI 的帮助

/// A naive httpie implementation with Rust, can you imagine how easy it is?
#[derive(Clap, Debug)]
#[clap(version = &quot;1.0&quot;, author = &quot;Tyr Chen &lt;tyr@chen.com&gt;&quot;)]
#[clap(setting = AppSettings::ColoredHelp)]
struct Opts {
    #[clap(subcommand)]
    subcmd: SubCommand,
}

// 子命令分别对应不同的 HTTP 方法，目前只支持 get / post
#[derive(Clap, Debug)]
enum SubCommand {
    Get(Get),
    Post(Post),
    // 我们暂且不支持其它 HTTP 方法
}

// get 子命令

/// feed get with an url and we will retrieve the response for you
#[derive(Clap, Debug)]
struct Get {
    /// HTTP 请求的 URL
    #[clap(parse(try_from_str = parse_url))]
    url: String,
}

// post 子命令。需要输入一个 URL，和若干个可选的 key=value，用于提供 json body

/// feed post with an url and optional key=value pairs. We will post the data
/// as JSON, and retrieve the response for you
#[derive(Clap, Debug)]
struct Post {
    /// HTTP 请求的 URL
    #[clap(parse(try_from_str = parse_url))]
    url: String,
    /// HTTP 请求的 body
    #[clap(parse(try_from_str=parse_kv_pair))]
    body: Vec&lt;KvPair&gt;,
}

/// 命令行中的 key=value 可以通过 parse_kv_pair 解析成 KvPair 结构
#[derive(Debug, PartialEq)]
struct KvPair {
    k: String,
    v: String,
}

/// 当我们实现 FromStr trait 后，可以用 str.parse() 方法将字符串解析成 KvPair
impl FromStr for KvPair {
    type Err = anyhow::Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        // 使用 = 进行 split，这会得到一个迭代器
        let mut split = s.split(&quot;=&quot;);
        let err = || anyhow!(format!(&quot;Failed to parse {}&quot;, s));
        Ok(Self {
            // 从迭代器中取第一个结果作为 key，迭代器返回 Some(T)/None
            // 我们将其转换成 Ok(T)/Err(E)，然后用 ? 处理错误
            k: (split.next().ok_or_else(err)?).to_string(),
            // 从迭代器中取第二个结果作为 value
            v: (split.next().ok_or_else(err)?).to_string(),
        })
    }
}

/// 因为我们为 KvPair 实现了 FromStr，这里可以直接 s.parse() 得到 KvPair
fn parse_kv_pair(s: &amp;str) -&gt; Result&lt;KvPair&gt; {
    Ok(s.parse()?)
}

fn parse_url(s: &amp;str) -&gt; Result&lt;String&gt; {
    // 这里我们仅仅检查一下 URL 是否合法
    let _url: Url = s.parse()?;

    Ok(s.into())
}

/// 处理 get 子命令
async fn get(client: Client, args: &amp;Get) -&gt; Result&lt;()&gt; {
    let resp = client.get(&amp;args.url).send().await?;
    Ok(print_resp(resp).await?)
}

/// 处理 post 子命令
async fn post(client: Client, args: &amp;Post) -&gt; Result&lt;()&gt; {
    let mut body = HashMap::new();
    for pair in args.body.iter() {
        body.insert(&amp;pair.k, &amp;pair.v);
    }
    let resp = client.post(&amp;args.url).json(&amp;body).send().await?;
    Ok(print_resp(resp).await?)
}

// 打印服务器版本号 + 状态码
fn print_status(resp: &amp;Response) {
    let status = format!(&quot;{:?} {}&quot;, resp.version(), resp.status()).blue();
    println!(&quot;{}\n&quot;, status);
}

// 打印服务器返回的 HTTP header
fn print_headers(resp: &amp;Response) {
    for (name, value) in resp.headers() {
        println!(&quot;{}: {:?}&quot;, name.to_string().green(), value);
    }

    print!(&quot;\n&quot;);
}

/// 打印服务器返回的 HTTP body
fn print_body(m: Option&lt;Mime&gt;, body: &amp;String) {
    match m {
        // 对于 &quot;application/json&quot; 我们 pretty print
        Some(v) if v == mime::APPLICATION_JSON =&gt; {
            println!(&quot;{}&quot;, jsonxf::pretty_print(body).unwrap().cyan())
        }
        // 其它 mime type，我们就直接输出
        _ =&gt; println!(&quot;{}&quot;, body),
    }
}

/// 打印整个响应
async fn print_resp(resp: Response) -&gt; Result&lt;()&gt; {
    print_status(&amp;resp);
    print_headers(&amp;resp);
    let mime = get_content_type(&amp;resp);
    let body = resp.text().await?;
    print_body(mime, &amp;body);
    Ok(())
}

/// 将服务器返回的 content-type 解析成 Mime 类型
fn get_content_type(resp: &amp;Response) -&gt; Option&lt;Mime&gt; {
    resp.headers()
        .get(header::CONTENT_TYPE)
        .map(|v| v.to_str().unwrap().parse().unwrap())
}

/// 程序的入口函数，因为在 HTTP 请求时我们使用了异步处理，所以这里引入 tokio
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let opts: Opts = Opts::parse();
    let mut headers = header::HeaderMap::new();
    // 为我们的 HTTP 客户端添加一些缺省的 HTTP 头
    headers.insert(&quot;X-POWERED-BY&quot;, &quot;Rust&quot;.parse()?);
    headers.insert(header::USER_AGENT, &quot;Rust Httpie&quot;.parse()?);
    let client = reqwest::Client::builder()
        .default_headers(headers)
        .build()?;
    let result = match opts.subcmd {
        SubCommand::Get(ref args) =&gt; get(client, args).await?,
        SubCommand::Post(ref args) =&gt; post(client, args).await?,
    };

    Ok(result)
}

// 仅在 cargo test 时才编译
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_url_works() {
        assert!(parse_url(&quot;abc&quot;).is_err());
        assert!(parse_url(&quot;http://abc.xyz&quot;).is_ok());
        assert!(parse_url(&quot;https://httpbin.org/post&quot;).is_ok());
    }

    #[test]
    fn parse_kv_pair_works() {
        assert!(parse_kv_pair(&quot;a&quot;).is_err());
        assert_eq!(
            parse_kv_pair(&quot;a=1&quot;).unwrap(),
            KvPair {
                k: &quot;a&quot;.into(),
                v: &quot;1&quot;.into()
            }
        );

        assert_eq!(
            parse_kv_pair(&quot;b=&quot;).unwrap(),
            KvPair {
                k: &quot;b&quot;.into(),
                v: &quot;&quot;.into()
            }
        );
    }
}
</code></pre></pre>
<p>在这个完整代码的最后，我还撰写了几个单元测试，你可以用 cargo test 运行。Rust 支持条件编译，这里 #[cfg(test)] 表明整个 mod tests 都只在 cargo test 时才编译。</p>
<p>使用<a href="https://github.com/XAMPPRocky/tokei">代码行数统计工具 tokei</a> 可以看到，我们总共使用了 139 行代码，就实现了这个功能，其中还包含了约 30 行的单元测试代码：</p>
<pre><code class="language-bash">❯ tokei src/main.rs
-------------------------------------------------------------------------------
 Language            Files        Lines         Code     Comments       Blanks
-------------------------------------------------------------------------------
 Rust                    1          200          139           33           28
-------------------------------------------------------------------------------
 Total                   1          200          139           33           28
-------------------------------------------------------------------------------
</code></pre>
<p>你可以使用 cargo build --release，编译出 release 版本，并将其拷贝到某个在 $PATH下的目录，然后体验一下：</p>
<p><img src="./release.webp" alt="" /></p>
<p>到这里一个带有完整帮助的 HTTPie 就可以投入使用了。</p>
<p>我们测试一下效果：</p>
<p><img src="./workout.webp" alt="" /></p>
<p>这和官方的 HTTPie 效果几乎一样。</p>
<p>哈，这个例子我们大获成功。我们只用了 100 行代码出头，就实现了 HTTPie 的核心功能，远低于预期的 200 行。不知道你能否从中隐约感受到 Rust 解决实际问题的能力，以今天实现的 HTTPie 为例，</p>
<ul>
<li>要把命令行解析成数据结构，我们只需要在数据结构上，添加一些简单的标注就能搞定。</li>
<li>数据的验证，又可以由单独的、和主流程没有任何耦合关系的函数完成。</li>
<li>作为 CLI 解析库，clap 的整体体验和 Python 的 <a href="https://click.palletsprojects.com/en/8.0.x/">click</a> 非常类似，但比 Golang 的 <a href="https://github.com/spf13/cobra">cobra</a> 要更简单。</li>
</ul>
<p>这就是 Rust 语言的能力体现，明明是面向系统级开发，却能够做出类似 Python 的抽象和体验，所以一旦你适应了 Rust ，用起来就会感觉非常美妙。</p>
<h2 id="小结"><a class="header" href="#小结">小结</a></h2>
<p>现在你应该有点明白，为什么我会在开篇词中会说，Rust 拥有强大的表现力。</p>
<p>或许你还是有点疑惑，这么学，我也太懵了，跟盲人摸象似的。其实初学者都会以为，必须要先搞明白所有的语法知识，才能动手写代码，不是的。</p>
<p>我们这周写三个实用例子的挑战，就是为了让你，在懵懂地撰写代码的过程中，直观感受 Rust 处理问题、解决问题的方式，同时可以跟你熟悉的语言去类比，无论是 Golang / Java，还是 Python / JavaScript，如果我用自己熟悉的语言怎么解决、Rust 给了我什么样的支持、我感觉它还缺什么。</p>
<p>在这个过程中，你脑子里会产生各种深度的思考，这些思考又必然会引发越来越多的问号，这是好事，带着这些问号，在未来的课程中才能更有目的地学习，也一定会学得深刻而有效。</p>
<p>今天的小挑战并不太难，你可能还意犹未尽。别急，下一讲我们会再写个难度大一点的、工作中都会用到的 Web 服务，继续体验 Rust 的魅力。</p>
<h2 id="思考题"><a class="header" href="#思考题">思考题</a></h2>
<p>我们只是实现了 HTTP header 和 body 的高亮区分，但是 HTTP body 还是有些不太美观，可以进一步做语法高亮，如果你完成了今天的代码，觉得自己学有余力可以再挑战一下，你不妨试一试用 <a href="https://github.com/trishume/syntect">syntect</a> 继续完善我们的 HTTPie。syntect 是 Rust 的一个语法高亮库，非常强大。</p>

                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../3-codeup/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../5-thumbor/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../3-codeup/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../5-thumbor/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript" charset="utf-8">
        var pagePath = "4-httpie/index.md"
        </script>


        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../assets/custom.js"></script>
        <script type="text/javascript" src="../assets/bigPicture.js"></script>


    </body>
</html>